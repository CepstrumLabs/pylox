from pathlib import Path
from datetime import datetime


NEWLINE = "\n"
TAB = "\t"



class Writer():
    
    def __init__(self, path):
        self.path = path

    def write(self, content):
        with open(self.path, 'w') as outfile:
            outfile.write(content)


def define_ast(output_dir, base_name, types):
    path = Path(output_dir) / f"{base_name}.py"
    writer = Writer(path)
    source = _add_autogenerated_banner()
    source += "from pylox.scanner import LoxToken as Token" + 2 * NEWLINE
    source += create_abstract_class(name=base_name)
    source += _add_abstract_method(name="accept", class_name=base_name)
    for type_ in types:
        class_name = type_.split(":")[0].strip()
        class_fields = type_.split(":")[1].strip()
        source += define_type(parent_class_name=base_name, class_name=class_name, fields=class_fields) + NEWLINE
    writer.write(source)
    return source

def _add_autogenerated_banner():
    _date = datetime.now().strftime("%B %d, %Y %H:%M:%S")
    source = "# This file was autogenerated by pylox" + NEWLINE
    source += f"# on {_date}" + NEWLINE
    return source

def _add_abstract_method(name, class_name):
    source = TAB + f"def {name}(self, visitor: '{class_name}Visitor'):" + NEWLINE
    source += 2 * TAB + "raise NotImplementedError('Subclasses should implement this method')" + 2 * NEWLINE
    return source

def create_abstract_class(name):
    return f"class {name}:{NEWLINE}{TAB}pass{NEWLINE}{NEWLINE}"

def define_type(parent_class_name, class_name, fields):
    field_defs = [part.split() for part in fields.split(",")]
    source = f"class {class_name}({parent_class_name}):" + 2 * NEWLINE
    source += _add_init_method(field_defs)
    source += _add_accept_method(parent_class_name, class_name)
    return source

def _add_init_method(field_defs):
    source = TAB + "def __init__(self, " + ', '.join([f"{field_def[1]}: {field_def[0]}" for  field_def in field_defs]) + "):" + NEWLINE
    for field_def in field_defs:
        source += 2 * TAB + f"self.{field_def[1]} = {field_def[1]}" + NEWLINE
    source += NEWLINE
    return source

def _add_accept_method(parent_class_name, class_name):
    source = TAB + f"def accept(self, visitor: '{parent_class_name}Visitor'):" + NEWLINE
    source += 2 * TAB + f"return visitor.visit{class_name}{parent_class_name}(self)" + 2 * NEWLINE
    return source

def generate_ast(directory):
    output_dir = directory
    base_name = "Expr"
    TYPES = [
        "Binary: Expr left, Token operator, Expr right",
        "Unary: Token operator, Expr right",
        "Literal: object value", 
        "Grouping: Expr expression"
    ]

    define_ast(output_dir=output_dir, base_name=base_name, types=TYPES)


if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("--output-dir", type=Path, required=True)
    args = parser.parse_args()

    directory = Path(args.output_dir)
    if not directory.exists():
        raise OSError(f"Directory {directory} does not exist")
    source = generate_ast(directory=directory)

