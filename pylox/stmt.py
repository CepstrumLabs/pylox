# This file was autogenerated by pylox
# on June 19, 2022 17:21:33
from typing import List

from pylox.scanner import LoxToken as Token


class Stmt:
    def accept(self, visitor: "StmtVisitor"):
        raise NotImplementedError("Subclasses should implement this method")


class Expression(Stmt):
    def __init__(self, expression: "Expr"):
        self.expression = expression

    def accept(self, visitor: "StmtVisitor"):
        return visitor.visit_expression_stmt(self)

    def __repr__(self):
        return f"{self.__class__.__name__}(expression={self.expression})"

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.expression == other.expression


class Print(Stmt):
    def __init__(self, expression: "Expr"):
        self.expression = expression

    def accept(self, visitor: "StmtVisitor"):
        return visitor.visit_print_stmt(self)

    def __repr__(self):
        return f"{self.__class__.__name__}(expression={self.expression})"

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.expression == other.expression


class Var(Stmt):
    def __init__(self, name: "Token", initialiser: "Expr"):
        self.name = name
        self.initialiser = initialiser

    def accept(self, visitor: "StmtVisitor"):
        return visitor.visit_var_stmt(self)

    def __repr__(self):
        return f"{self.__class__.__name__}(name={self.name}, initialiser={self.initialiser})"

    def __eq__(self, other):
        return (
            isinstance(other, self.__class__)
            and self.name == other.name
            and self.initialiser == other.initialiser
        )


class Block(Stmt):
    def __init__(self, statements: "List[Stmt]"):
        self.statements = statements

    def accept(self, visitor: "StmtVisitor"):
        return visitor.visit_block_stmt(self)

    def __repr__(self):
        return f"{self.__class__.__name__}(statements={self.statements})"

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.statements == other.statements


class If(Stmt):
    def __init__(self, condition: "Expr", then_branch: "Stmt", else_branch: "Stmt"):
        self.condition = condition
        self.then_branch = then_branch
        self.else_branch = else_branch

    def accept(self, visitor: "StmtVisitor"):
        return visitor.visit_if_stmt(self)

    def __repr__(self):
        return f"{self.__class__.__name__}(condition={self.condition}, then_branch={self.then_branch}, else_branch={self.else_branch})"

    def __eq__(self, other):
        return (
            isinstance(other, self.__class__)
            and self.condition == other.condition
            and self.then_branch == other.then_branch
            and self.else_branch == other.else_branch
        )


class While(Stmt):
    def __init__(self, condition: "Expr", statement: "Stmt"):
        self.condition = condition
        self.statement = statement

    def accept(self, visitor: "StmtVisitor"):
        return visitor.visit_while_stmt(self)

    def __repr__(self):
        return f"{self.__class__.__name__}(condition={self.condition}, statement={self.statement})"

    def __eq__(self, other):
        return (
            isinstance(other, self.__class__)
            and self.condition == other.condition
            and self.statement == other.statement
        )


class Function(Stmt):
    def __init__(self, name: "Token", body: "List[Stmt]", params: "List[Token]"):
        self.name = name
        self.body = body
        self.params = params

    def accept(self, visitor: "StmtVisitor"):
        return visitor.visit_function_stmt(self)

    def __repr__(self):
        return f"{self.__class__.__name__}(name={self.name}, body={self.body}, params={self.params})"

    def __eq__(self, other):
        return (
            isinstance(other, self.__class__)
            and self.name == other.name
            and self.body == other.body
            and self.params == other.params
        )


class Return(Stmt):
    def __init__(self, keyword: "Token", value: "Expr"):
        self.keyword = keyword
        self.value = value

    def accept(self, visitor: "StmtVisitor"):
        return visitor.visit_return_stmt(self)

    def __repr__(self):
        return f"{self.__class__.__name__}(keyword={self.keyword}, value={self.value})"

    def __eq__(self, other):
        return (
            isinstance(other, self.__class__)
            and self.keyword == other.keyword
            and self.value == other.value
        )
